import pygame
import sys
from typing import List, Optional, Tuple
from .constants import *
from .card import Carte
from .deck import Deck
from .player import Joueur

class ChequeGames:
    def __init__(self, ecran):
        self.ecran = ecran
        self.police = pygame.font.Font(None, 36)
        self.gros_texte = pygame.font.Font(None, 48)
        
        # Initialisation des composants du jeu
        self.paquet = Deck()
        self.joueur = Joueur("Joueur", est_ia=False)
        self.ia = Joueur("IA", est_ia=True)
        self.joueur_actif = self.joueur  # Le joueur commence
        self.partie_terminee = False
        self.gagnant = None
        self.passer_tour = False
        self.cartes_a_piocher = 0
        self.symbole_force = None  # Pour forcer un symbole (effet du Valet)
        self.dernier_joueur = None  # Pour le cas o√π le joueur gagne mais l'adversaire peut encore jouer
        
        # Variables pour le glisser-d√©poser
        self.carte_selectionnee = None
        self.drag_en_cours = False
        self.dernier_clic = 0  # Pour la d√©tection du double-clic
        
        # Variables pour l'animation de l'IA
        self.ia_en_cours = False
        self.ia_carte_jouee = None
        self.ia_position_finale = PILE_POS
        self.ia_temps_animation = 0
        self.ia_delai_entre_tours = 1000  # 1 seconde entre les tours de l'IA
        self.dernier_tour_ia = 0
        
        # Pour g√©rer l'effet de l'As (rejouer)
        self.as_joue = False  # Indique si un As a √©t√© jou√© au tour pr√©c√©dent
        
        # Pour g√©rer le blocage des effets par un Valet
        self.effet_bloque_par_valet = False  # Indique si un effet a √©t√© bloqu√© par un Valet
        
        # Variables pour l'animation de pioche
        self.animation_pioche = None  # Carte en cours d'animation
        self.animation_pioche_depart = None  # Position de d√©part de l'animation
        self.animation_pioche_arrivee = None  # Position d'arriv√©e de l'animation
        self.animation_pioche_debut = 0  # Temps de d√©but de l'animation
        self.animation_pioche_duree = 500  # Dur√©e de l'animation en ms
        
        # Distribution des cartes initiales
        self._distribuer_cartes_initiales()
        
        # Premi√®re carte de la d√©fausse (doit √™tre une carte normale)
        while True:
            premiere_carte = self.paquet.piocher(1)[0]
            if not premiere_carte.est_speciale() or premiere_carte.valeur == 2:  # On accepte le 2 (passe-partout)
                self.paquet.ajouter_defausse(premiere_carte)
                break
            else:
                # Remettre la carte sp√©ciale dans le paquet
                self.paquet.cartes.insert(0, premiere_carte)
    
    def _demarrer_animation_pioche(self, carte, depart, arrivee):
        """D√©marre une animation de pioche"""
        self.animation_pioche = carte
        self.animation_pioche_depart = depart
        self.animation_pioche_arrivee = arrivee
        self.animation_pioche_debut = pygame.time.get_ticks()
    
    def _mettre_a_jour_animation_pioche(self):
        """Met √† jour l'animation de pioche et retourne True si elle est termin√©e"""
        if not self.animation_pioche:
            return True
            
        temps_ecoule = pygame.time.get_ticks() - self.animation_pioche_debut
        progression = min(temps_ecoule / self.animation_pioche_duree, 1.0)
        
        # Calcul de la position actuelle (interpolation lin√©aire)
        x = self.animation_pioche_depart[0] + (self.animation_pioche_arrivee[0] - self.animation_pioche_depart[0]) * progression
        y = self.animation_pioche_depart[1] + (self.animation_pioche_arrivee[1] - self.animation_pioche_depart[1]) * progression
        
        # Mettre √† jour la position de la carte
        self.animation_pioche.rect.x = x
        self.animation_pioche.rect.y = y
        
        # Si l'animation est termin√©e
        if progression >= 1.0:
            self.animation_pioche = None
            return True
        return False
    
    def afficher_menu_choix_symbole(self):
        """Affiche un menu pour choisir un nouveau symbole"""
        if not hasattr(self, 'menu_actif') or not self.menu_actif:
            self.menu_actif = True
            self.symbole_choisi = None
            
            # Calculer la position du menu (au centre de l'√©cran)
            menu_x = SCREEN_WIDTH // 2 - 100
            menu_y = SCREEN_HEIGHT // 2 - 50
            
            # Cr√©er des boutons pour chaque symbole
            self.boutons_symbole = []
            symboles = [Symbole.COEUR, Symbole.CARREAU, Symbole.TREFLE, Symbole.PIQUE]
            noms_symboles = {
                Symbole.COEUR: "C≈ìur",
                Symbole.CARREAU: "Carreau",
                Symbole.TREFLE: "Tr√®fle",
                Symbole.PIQUE: "Pique"
            }
            
            for i, symbole in enumerate(symboles):
                bouton = {
                    'rect': pygame.Rect(menu_x + (i % 2) * 120, menu_y + (i // 2) * 60, 100, 50),
                    'symbole': symbole,
                    'texte': noms_symboles[symbole]
                }
                self.boutons_symbole.append(bouton)
                
    def _distribuer_cartes_initiales(self):
        """Distribue les cartes initiales aux joueurs"""
        # Distribuer 5 cartes √† chaque joueur
        for _ in range(INITIAL_CARDS):
            self.joueur.recevoir_cartes(self.paquet.piocher(1))
            self.ia.recevoir_cartes(self.paquet.piocher(1))
    
    def changer_joueur(self):
        """Passe au joueur suivant"""
        print(f"[DEBUG] changer_joueur - Avant changement: joueur_actif={self.joueur_actif.nom}, dernier_joueur={getattr(self, 'dernier_joueur', None)}, dernier_chance={getattr(self, 'derniere_chance', False)}")
        
        # V√©rifier si un effet a √©t√© bloqu√© par un Valet
        if self.effet_bloque_par_valet and not self.partie_terminee:
            print(f"[DEBUG] Effet bloqu√© par un Valet, {self.joueur_actif.nom} rejoue")
            self.effet_bloque_par_valet = False  # R√©initialiser pour le prochain tour
            return  # Le m√™me joueur rejoue
            
        # V√©rifier si un As a √©t√© jou√© au tour pr√©c√©dent
        if self.as_joue and not self.partie_terminee:
            print(f"[DEBUG] Un As a √©t√© jou√©, {self.joueur_actif.nom} rejoue")
            self.as_joue = False  # R√©initialiser pour le prochain tour
            return  # Le m√™me joueur rejoue
        
        if hasattr(self, 'derniere_chance') and self.derniere_chance:
            # Si c'√©tait la derni√®re chance de l'adversaire, la partie est termin√©e
            self.partie_terminee = True
            self.gagnant = self.dernier_joueur
            print(f"La partie est termin√©e ! {self.gagnant.nom} a gagn√© !")
            print(f"[DEBUG] Fin de partie - Derni√®re chance, gagnant: {self.gagnant.nom}")
            return
            
        # Si le joueur actuel n'a plus de cartes, il gagne la partie
        if not self.joueur_actif.main:
            self.partie_terminee = True
            self.gagnant = self.joueur_actif
            print(f"La partie est termin√©e ! {self.gagnant.nom} a gagn√© en se d√©barrassant de toutes ses cartes !")
            print(f"[DEBUG] Fin de partie - Plus de cartes, gagnant: {self.gagnant.nom}")
            return
            
        if self.passer_tour:
            ancien_joueur = self.joueur_actif.nom
            print(f"{ancien_joueur} passe son tour!")
            self.passer_tour = False
            # On saute le tour du joueur actuel
            self.joueur_actif = self.ia if self.joueur_actif == self.joueur else self.joueur
            print(f"[DEBUG] Passage de tour: {ancien_joueur} -> {self.joueur_actif.nom}")
            print(f"\n--- Tour de {self.joueur_actif.nom} ---")
            return
            
        # Changer de joueur normalement
        ancien_joueur = self.joueur_actif.nom
        self.joueur_actif = self.ia if self.joueur_actif == self.joueur else self.joueur
        print(f"[DEBUG] Changement de joueur: {ancien_joueur} -> {self.joueur_actif.nom}")
        print(f"\n--- Tour de {self.joueur_actif.nom} ---")
        
        # Si c'est le tour de l'IA, d√©marrer son tour
        if self.joueur_actif == self.ia and not self.partie_terminee:
            print("[DEBUG] D√©marrage du tour de l'IA depuis changer_joueur")
            self.ia_en_cours = True
            self.dernier_tour_ia = pygame.time.get_ticks()
    
    def commencer_tour_ia(self):
        """D√©marre le tour de l'IA avec un d√©lai"""
        if not self.partie_terminee and self.joueur_actif == self.ia:
            self.ia_en_cours = True
            self.dernier_tour_ia = pygame.time.get_ticks()
    
    def jouer_tour_ia(self):
        """Fait jouer l'IA"""
        print(f"\n[DEBUG] D√©but de jouer_tour_ia - Tour de l'IA")
        
        # V√©rifier si l'IA doit piocher des cartes
        if self.cartes_a_piocher > 0:
            print(f"[DEBUG] L'IA doit piocher {self.cartes_a_piocher} cartes")
            self.piocher_carte()
            return True
            
        # Logique de jeu de l'IA
        print("[DEBUG] Recherche d'une carte jouable pour l'IA.")
        derniere_carte = self.paquet.obtenir_derniere_carte_defausse()
        print(f"[DEBUG] Derni√®re carte sur la d√©fausse: {derniere_carte}")
        
        # 1. Chercher une carte sp√©ciale (As, 7, Valet, Joker)
        for i, carte in enumerate(self.ia.main):
            if carte.valeur in [0, 1, 7, 11]:  # Joker, As, 7, Valet
                if not derniere_carte or carte.peut_etre_jouee_sur(derniere_carte):
                    print(f"[DEBUG] L'IA joue une carte sp√©ciale: {carte}")
                    return self.jouer_carte_ia(i)
        
        # 2. Chercher une carte de m√™me symbole ou valeur forc√©e
        if derniere_carte:
            for i, carte in enumerate(self.ia.main):
                if (carte.symbole == derniere_carte.symbole or 
                    (self.symbole_force and carte.symbole == self.symbole_force)):
                    print(f"[DEBUG] L'IA joue une carte de m√™me symbole/forc√©e: {carte}")
                    return self.jouer_carte_ia(i)
            
            # 3. Chercher une carte de m√™me valeur
            for i, carte in enumerate(self.ia.main):
                if carte.valeur == derniere_carte.valeur:
                    print(f"[DEBUG] L'IA joue une carte de m√™me valeur: {carte}")
                    return self.jouer_carte_ia(i)
        
        # Si aucune carte ne peut √™tre jou√©e, piocher
        print("[DEBUG] Aucune carte jouable trouv√©e, l'IA pioche une carte")
        self.piocher_carte()
        return True
        
    def jouer_carte_ia(self, index_carte):
        """M√©thode utilitaire pour jouer une carte avec l'IA"""
        if 0 <= index_carte < len(self.ia.main):
            carte = self.ia.main[index_carte]
            print(f"IA joue : {carte}")
            self.ia_carte_jouee = carte
            self.ia_temps_animation = pygame.time.get_ticks()
            
            # Jouer la carte
            if self.jouer_carte(index_carte):
                print("[DEBUG] Carte jou√©e avec succ√®s par l'IA")
                return True
            else:
                print("[ERREUR] √âchec de la tentative de jouer la carte, l'IA va piocher")
                self.ia_carte_jouee = None
                self.piocher_carte()
                return True
        return False
    
    def afficher_menu_choix_symbole(self):
        """Affiche un menu pour choisir un nouveau symbole"""
        if not hasattr(self, 'menu_actif') or not self.menu_actif:
            self.menu_actif = True
            self.symbole_choisi = None
            
            # Calculer la position du menu (au centre de l'√©cran)
            menu_x = SCREEN_WIDTH // 2 - 100
            menu_y = SCREEN_HEIGHT // 2 - 50
            
            # Cr√©er des boutons pour chaque symbole
            self.boutons_symbole = []
            symboles = [Symbole.COEUR, Symbole.CARREAU, Symbole.TREFLE, Symbole.PIQUE]
            noms_symboles = {
                Symbole.COEUR: "C≈ìur",
                Symbole.CARREAU: "Carreau",
                Symbole.TREFLE: "Tr√®fle",
                Symbole.PIQUE: "Pique"
            }
            
            for i, symbole in enumerate(symboles):
                bouton = {
                    'rect': pygame.Rect(menu_x + (i % 2) * 120, menu_y + (i // 2) * 60, 100, 50),
                    'symbole': symbole,
                    'texte': noms_symboles[symbole]
                }
                self.boutons_symbole.append(bouton)
    
    def jouer_carte(self, index_carte: int) -> bool:
        """Tente de jouer une carte"""
        if not (0 <= index_carte < len(self.joueur_actif.main)):
            return False
            
        derniere_carte = self.paquet.obtenir_derniere_carte_defausse()
        carte_a_jouer = self.joueur_actif.main[index_carte]
        
        # Si c'est un Valet et qu'il n'y a pas d'attaque en cours, afficher le menu de s√©lection
        if carte_a_jouer.valeur == 11 and self.cartes_a_piocher == 0 and not hasattr(self, 'menu_actif'):
            print("[DEBUG] Affichage du menu de s√©lection de symbole pour le Valet")
            self.afficher_menu_choix_symbole()
            # Stocker l'index de la carte Valet pour pouvoir la jouer apr√®s la s√©lection du symbole
            self.carte_valet_en_attente = index_carte
            return False  # On attend que l'utilisateur choisisse un symbole
        
        # V√©rifier si la carte peut √™tre jou√©e
        if not (carte_a_jouer.peut_etre_jouee_sur(derniere_carte) or 
               (self.symbole_force and carte_a_jouer.symbole == self.symbole_force)):
            print(f"Carte invalide : {carte_a_jouer} ne peut pas √™tre jou√©e sur {derniere_carte}")
            return False
        
        # V√©rifier si on peut contrer une attaque (7 ou Joker) ou bloquer avec un Valet
        if self.cartes_a_piocher > 0:
            if carte_a_jouer.valeur not in [7, 0, 11]:  # 7, Joker (0) ou Valet (11)
                print(f"Vous devez jouer un 7, un Joker ou un Valet pour contrer l'attaque de {self.cartes_a_piocher} cartes!")
                return False
                
            # Si c'est un Valet qui est jou√© pour bloquer un effet
            if carte_a_jouer.valeur == 11 and self.cartes_a_piocher > 0:
                print(f"{self.joueur_actif.nom} utilise un Valet pour bloquer l'effet de la carte pr√©c√©dente !")
                self.effet_bloque_par_valet = True
                self.cartes_a_piocher = 0  # Annule l'effet de pioche
                
                # Jouer la carte normalement (sans effet sp√©cial)
                carte_jouee = self.joueur_actif.jouer_carte(index_carte)
                self.paquet.ajouter_defausse(carte_jouee)
                print(f"{self.joueur_actif.nom} joue : {carte_jouee} (effet bloqu√©)")
                
                # V√©rifier si le joueur a gagn√©
                if not self.joueur_actif.main:
                    self.dernier_joueur = self.joueur_actif
                    self.derniere_chance = True
                    self.changer_joueur()
                else:
                    self.changer_joueur()
                return True
            
        # R√©initialiser le symbole forc√© si on joue une carte valide
        if self.symbole_force and carte_a_jouer.symbole == self.symbole_force:
            self.symbole_force = None
        
        # La carte peut √™tre jou√©e
        carte_jouee = self.joueur_actif.jouer_carte(index_carte)
        self.paquet.ajouter_defausse(carte_jouee)
        print(f"{self.joueur_actif.nom} joue : {carte_jouee}")
        
        # Gestion des contre-attaques (7 ou Joker)
        if self.cartes_a_piocher > 0 and carte_jouee.valeur in [7, 0]:
            if carte_jouee.valeur == 7:  # 7 ajoute 2 cartes
                self.cartes_a_piocher += 2
                print(f"Contre-attaque ! {self.joueur_actif.nom} ajoute 2 cartes. Total √† piocher: {self.cartes_a_piocher}")
            else:  # Joker ajoute 4 cartes
                self.cartes_a_piocher += 4
                print(f"Contre-attaque JOKER ! {self.joueur_actif.nom} ajoute 4 cartes. Total √† piocher: {self.cartes_a_piocher}")
            
            # V√©rifier si le joueur a gagn√© apr√®s avoir jou√© sa carte de contre-attaque
            if not self.joueur_actif.main:
                self.dernier_joueur = self.joueur_actif
                self.derniere_chance = True
                self.changer_joueur()
            else:
                self.changer_joueur()  # Passe √† l'adversaire qui peut contre-attaquer
            return True
        
        # Appliquer les effets sp√©ciaux (sauf si c'est un Valet qui a d√©j√† √©t√© trait√©)
        if carte_jouee.est_speciale() and carte_jouee.valeur != 11:  # Ne pas appliquer l'effet du Valet ici
            carte_jouee.appliquer_effet(self)
        
        # V√©rifier si le joueur a gagn√© (plus de cartes en main)
        if not self.joueur_actif.main:
            self.dernier_joueur = self.joueur_actif
            self.derniere_chance = True  # Donner une derni√®re chance √† l'adversaire
            self.changer_joueur()
            return True
            
        # Gestion des effets de cartes sp√©ciales
        if carte_jouee.valeur == 1:  # As - Le joueur actif rejoue
            print(f"{self.joueur_actif.nom} joue un As ! Il rejoue.")
            self.as_joue = True  # Active l'effet de l'As pour le prochain tour
            # Ne pas appeler changer_joueur() ici, le joueur actif rejoue
            return True
            
        if carte_jouee.valeur == 7:  # 7 - Fait piocher 2 cartes √† l'adversaire
            print(f"{self.joueur_actif.nom} joue un 7 ! L'adversaire doit piocher 2 cartes.")
            self.cartes_a_piocher = 2
            self.changer_joueur()  # Passe au tour de l'adversaire qui pourra contre-attaquer
            return True
            
        if carte_jouee.valeur == 11:  # Valet - Change la couleur
            print(f"{self.joueur_actif.nom} joue un Valet et change la couleur.")
            # Le symbole a d√©j√† √©t√© choisi via l'interface
            if hasattr(self, 'symbole_choisi') and self.symbole_choisi:
                print(f"La couleur a √©t√© chang√©e en {self.symbole_choisi.name}")
                self.symbole_force = self.symbole_choisi
                delattr(self, 'symbole_choisi')
            self.changer_joueur()
            return True
            
        if carte_jouee.valeur == 0:  # Joker - Fait piocher 4 cartes √† l'adversaire
            print(f"JOKER ! {self.joueur_actif.nom} fait piocher 4 cartes √† l'adversaire !")
            self.cartes_a_piocher = 4
            self.changer_joueur()  # Passe au tour de l'adversaire qui pourra contre-attaquer
            return True
            
        # Pour les cartes normales, on passe simplement au tour suivant
        self.changer_joueur()
        return True
    
    def piocher_carte(self):
        """Fait piocher une carte au joueur actif et passe le tour √† l'adversaire"""
        print(f"[DEBUG] piocher_carte - D√©but - Joueur actif: {self.joueur_actif.nom}, cartes_a_piocher: {self.cartes_a_piocher}")
        
        if self.cartes_a_piocher > 0:
            # Cas o√π le joueur doit piocher des cartes √† cause d'un 7 ou d'un joker
            print(f"[DEBUG] Pioche forc√©e de {self.cartes_a_piocher} cartes pour {self.joueur_actif.nom}")
            cartes = self.paquet.piocher(self.cartes_a_piocher)
            if cartes:  # Si des cartes ont √©t√© pioch√©es
                # Position de d√©part de l'animation (haut de l'√©cran pour l'IA, bas pour le joueur)
                if self.joueur_actif.est_ia:
                    depart = (self.ecran.get_width() // 2, 0)
                else:
                    depart = (self.ecran.get_width() // 2, self.ecran.get_height())
                
                # Position d'arriv√©e (main du joueur)
                arrivee = (100 + len(self.joueur_actif.main) * 30, 
                          self.ecran.get_height() - 150 if not self.joueur_actif.est_ia else 50)
                
                # D√©marrer l'animation pour chaque carte
                for i, carte in enumerate(cartes):
                    # Positionner la carte pour l'animation
                    carte.rect.x, carte.rect.y = depart
                    # D√©marrer l'animation avec un l√©ger d√©calage pour chaque carte
                    pygame.time.delay(100 * i)  # D√©lai entre chaque animation
                    self._demarrer_animation_pioche(carte, depart, arrivee)
                    # Attendre que l'animation soit termin√©e
                    while not self._mettre_a_jour_animation_pioche():
                        pygame.time.delay(16)  # ~60 FPS
                        self.afficher()
                        pygame.display.flip()
                
                self.joueur_actif.recevoir_cartes(cartes)
                print(f"{self.joueur_actif.nom} pioche {len(cartes)} cartes!")
                self.cartes_a_piocher = 0
                
                # Le tour passe automatiquement √† l'adversaire apr√®s avoir pioch√©
                print(f"[DEBUG] Avant changement de joueur (pioche forc√©e)")
                self.changer_joueur()
                print(f"[DEBUG] Apr√®s changement de joueur (pioche forc√©e), nouveau joueur: {self.joueur_actif.nom}")
                
                # Si c'est au tour de l'IA, on active son tour
                if self.joueur_actif.est_ia and not self.partie_terminee:
                    print("[DEBUG] Activation du tour de l'IA apr√®s pioche forc√©e")
                    self.ia_en_cours = True
                    self.dernier_tour_ia = pygame.time.get_ticks()
            return
        
        # Pioche normale (quand le joueur ne peut pas jouer)
        print("[DEBUG] Pioche normale pour", self.joueur_actif.nom)
        cartes_piochees = self.paquet.piocher(1)
        if not cartes_piochees:  # Si le paquet est vide
            print("Plus de cartes dans le paquet!")
            self.partie_terminee = True
            return
        
        # Position de d√©part de l'animation (haut de l'√©cran pour l'IA, bas pour le joueur)
        if self.joueur_actif.est_ia:
            depart = (self.ecran.get_width() // 2, 0)
        else:
            depart = (self.ecran.get_width() // 2, self.ecran.get_height())
        
        # Position d'arriv√©e (main du joueur)
        arrivee = (100 + len(self.joueur_actif.main) * 30, 
                  self.ecran.get_height() - 150 if not self.joueur_actif.est_ia else 50)
        
        # D√©marrer l'animation
        derniere_carte_piochee = cartes_piochees[-1]
        derniere_carte_piochee.rect.x, derniere_carte_piochee.rect.y = depart
        self._demarrer_animation_pioche(derniere_carte_piochee, depart, arrivee)
        
        # Attendre que l'animation soit termin√©e
        while not self._mettre_a_jour_animation_pioche():
            pygame.time.delay(16)  # ~60 FPS
            self.afficher()
            pygame.display.flip()
            
        self.joueur_actif.recevoir_cartes(cartes_piochees)
        print(f"{self.joueur_actif.nom} pioche une carte: {derniere_carte_piochee}")
        
        # Piocher une carte termine automatiquement le tour du joueur
        print(f"[DEBUG] Avant changement de joueur (pioche normale), joueur actuel: {self.joueur_actif.nom}")
        self.changer_joueur()
        print(f"[DEBUG] Apr√®s changement de joueur (pioche normale), nouveau joueur: {self.joueur_actif.nom}")
        
        # Si c'est au tour de l'IA, on active son tour
        if self.joueur_actif.est_ia and not self.partie_terminee:
            print("[DEBUG] Activation du tour de l'IA apr√®s pioche normale")
            self.ia_en_cours = True
            self.dernier_tour_ia = pygame.time.get_ticks()
    
    def mettre_a_jour(self):
        """Met √† jour l'√©tat du jeu"""
        # V√©rifier si c'est le tour de l'IA et que la partie n'est pas termin√©e
        if self.joueur_actif == self.ia and not self.partie_terminee:
            print(f"\n[DEBUG] Tour de l'IA - ia_en_cours={self.ia_en_cours}, partie_terminee={self.partie_terminee}")
            
            # V√©rifier si l'IA n'a plus de cartes (victoire de l'IA)
            if not self.ia.main:
                print("[DEBUG] L'IA n'a plus de cartes, elle a gagn√©!")
                self.partie_terminee = True
                self.gagnant = self.ia
                return
                
            # Si l'IA n'est pas d√©j√† en train de jouer, d√©marrer son tour
            if not self.ia_en_cours:
                print("[DEBUG] D√©marrage du tour de l'IA")
                self.ia_en_cours = True
                self.dernier_tour_ia = pygame.time.get_ticks()
                return
                
            # V√©rifier si le d√©lai minimum est √©coul√©
            temps_actuel = pygame.time.get_ticks()
            if temps_actuel - self.dernier_tour_ia >= self.ia_delai_entre_tours:
                print("[DEBUG] Ex√©cution du tour de l'IA")
                # Jouer le tour de l'IA
                self.jouer_tour_ia()
        
        # V√©rifier si la partie est termin√©e (joueur n'a plus de cartes)
        if not self.partie_terminee and self.joueur_actif == self.joueur and not self.joueur.main:
            print("[DEBUG] Le joueur n'a plus de cartes, il a gagn√©!")
            self.animation_pioche.dessiner(self.ecran, (self.animation_pioche.rect.x, self.animation_pioche.rect.y))
        
        # Afficher la pioche (dos de carte) √† gauche de la d√©fausse
        if hasattr(self.paquet, 'cartes') and len(self.paquet.cartes) > 0:
            pioche_x = PILE_POS[0] - CARD_WIDTH - 20  # 20 pixels d'espacement
            pioche_y = PILE_POS[1]
            
            # Dessiner plusieurs cartes d√©cal√©es pour l'effet de pile
            nb_cartes_visibles = min(3, len(self.paquet.cartes))
            for i in range(nb_cartes_visibles):
                offset = i * 2  # D√©calage de 2 pixels pour chaque carte de la pile
                # Dessiner le rectangle de la carte avec une bordure
                pygame.draw.rect(self.ecran, (0, 0, 120), 
                              (pioche_x + offset, pioche_y + offset, 
                               CARD_WIDTH, CARD_HEIGHT))
                pygame.draw.rect(self.ecran, (200, 200, 200), 
                              (pioche_x + offset, pioche_y + offset, 
                               CARD_WIDTH, CARD_HEIGHT), 2)
            
            # Dessiner le dos de la carte principale par-dessus
            pygame.draw.rect(self.ecran, (0, 0, 150), 
                          (pioche_x, pioche_y, CARD_WIDTH, CARD_HEIGHT))
            pygame.draw.rect(self.ecran, (255, 255, 255), 
                          (pioche_x, pioche_y, CARD_WIDTH, CARD_HEIGHT), 2)
            
            # Ajouter un motif de carte retourn√©e
            pygame.draw.rect(self.ecran, (30, 30, 150), 
                          (pioche_x + 20, pioche_y + 20, 
                           CARD_WIDTH - 40, CARD_HEIGHT - 40))
            pygame.draw.rect(self.ecran, (80, 80, 200), 
                          (pioche_x + 30, pioche_y + 30, 
                           CARD_WIDTH - 60, CARD_HEIGHT - 60))
            
            # Afficher le nombre de cartes restantes dans un badge
            texte = self.police.render(str(len(self.paquet.cartes)), True, (255, 255, 255))
            # Cr√©er un fond arrondi pour le compteur
            counter_bg = pygame.Surface((texte.get_width() + 20, texte.get_height() + 10), pygame.SRCALPHA)
            pygame.draw.rect(counter_bg, (0, 0, 0, 180), 
                          (0, 0, texte.get_width() + 20, texte.get_height() + 10), 
                          border_radius=10)
            self.ecran.blit(counter_bg, (pioche_x + CARD_WIDTH - 30, pioche_y + CARD_HEIGHT - 30))
            # Afficher le texte du compteur
            self.ecran.blit(texte, (pioche_x + CARD_WIDTH - 20, pioche_y + CARD_HEIGHT - 25))
            
        # Afficher la pile de d√©fausse (zone de d√©p√¥t des cartes)
        if hasattr(self.paquet, 'defausse') and len(self.paquet.defausse) > 0:
            derniere_carte = self.paquet.defausse[-1]
            defausse_x = PILE_POS[0]
            defausse_y = PILE_POS[1]
            
            # Afficher plusieurs cartes d√©cal√©es pour l'effet de pile (comme pour la pioche)
            nb_cartes_visibles = min(3, len(self.paquet.defausse))
            for i in range(nb_cartes_visibles):
                offset = i * 2  # D√©calage de 2 pixels pour chaque carte de la pile
                # Dessiner le rectangle de la carte avec une bordure (m√™me style que la pioche)
                pygame.draw.rect(self.ecran, (0, 0, 120), 
                              (defausse_x + offset, defausse_y + offset, 
                               derniere_carte.rect.width, derniere_carte.rect.height))
                pygame.draw.rect(self.ecran, (200, 200, 200), 
                              (defausse_x + offset, defausse_y + offset, 
                               derniere_carte.rect.width, derniere_carte.rect.height), 2)
            
            # Afficher la derni√®re carte de la d√©fausse (face visible)
            derniere_carte.dessiner(self.ecran, (defausse_x, defausse_y))
            
            # Afficher un contour pour indiquer la zone de d√©p√¥t (seulement si c'est le tour du joueur)
            if self.joueur_actif == self.joueur and not hasattr(self, 'menu_actif'):
                # Utiliser la taille r√©elle de la carte pour le contour
                contour_width = derniere_carte.rect.width + 10
                contour_height = derniere_carte.rect.height + 10
                contour = pygame.Surface((contour_width, contour_height), pygame.SRCALPHA)
                pygame.draw.rect(contour, (255, 255, 255, 100), 
                              (0, 0, contour_width, contour_height), 2, border_radius=5)
                self.ecran.blit(contour, (defausse_x - 5, defausse_y - 5))
        
        # Afficher les cartes de l'IA (face cach√©e)
        for i, _ in enumerate(self.ia.main):
                        # Utiliser la largeur du dos de la carte ou la largeur par dÈfaut
            card_width = Carte._dos_carte.get_width() if hasattr(Carte, '_dos_carte') and Carte._dos_carte else CARD_WIDTH
                            # Utiliser la largeur rÈelle de la carte pour le positionnement
                card_width = Carte._dos_carte.get_width() if hasattr(Carte, '_dos_carte') and Carte._dos_carte else CARD_WIDTH
                x = 50 + i * (card_width // 2)  # Chevauchement partiel des cartes
            card_height = Carte._dos_carte.get_height() if hasattr(Carte, '_dos_carte') and Carte._dos_carte else CARD_HEIGHT
            if i > 0 and i == len(self.ia.main) - 1:
                x -= 20  # Ajustement pour la derni√®re carte
            y = AI_HAND_Y
            
            # Afficher le dos de la carte pour l'IA
            if hasattr(Carte, '_dos_carte') and Carte._dos_carte:
                self.ecran.blit(Carte._dos_carte, (x, y))
            else:
                                pygame.draw.rect(self.ecran, (0, 0, 150), (x, y, card_width, card_height), border_radius=5)
                                pygame.draw.rect(self.ecran, (0, 0, 0), (x, y, card_width, card_height), 2, border_radius=5)
        
        # Afficher les cartes du joueur (sauf celle en cours de d√©placement)
        for i, carte in enumerate(self.joueur.main):
            if i != self.carte_selectionnee:  # Ne pas afficher la carte s√©lectionn√©e ici
                                # Utiliser la largeur rÈelle de la carte pour le positionnement
                card_width = Carte._dos_carte.get_width() if hasattr(Carte, '_dos_carte') and Carte._dos_carte else CARD_WIDTH
                x = 50 + i * (card_width // 2)
                if i > 0 and i == len(self.joueur.main) - 1:
                    x -= 20
                y = PLAYER_HAND_Y
                # Mettre √† jour la position de la carte
                carte.rect.x = x
                carte.rect.y = y
                # Dessiner la carte √† sa position actuelle
                carte.dessiner(self.ecran, (x, y))
        
        # Afficher la carte s√©lectionn√©e par-dessus tout le reste
        if self.carte_selectionnee is not None and self.carte_selectionnee < len(self.joueur.main):
            carte = self.joueur.main[self.carte_selectionnee]
            # La position est d√©j√† mise √† jour par _gerer_deplacement_souris
            carte.dessiner(self.ecran, (carte.rect.x, carte.rect.y))
            
        # Afficher la carte que l'IA est en train de jouer
        if self.ia_carte_jouee is not None and self.ia_en_cours:
            # Calculer la position actuelle de la carte pendant l'animation
            temps_ecoule = pygame.time.get_ticks() - self.ia_temps_animation
            duree_animation = 500  # 0.5 seconde
            progression = min(temps_ecoule / duree_animation, 1.0)
            
            # Position de d√©part (main de l'IA)
            x_depart = 50 + (self.ia.main.index(self.ia_carte_jouee) if self.ia_carte_jouee in self.ia.main else 0) * (CARD_WIDTH // 2)
            y_depart = AI_HAND_Y
            
            # Position d'arriv√©e (pile de d√©fausse)
            x_arrivee = PILE_POS[0]
            y_arrivee = PILE_POS[1]
            
            # Position actuelle (interpolation lin√©aire)
            x = x_depart + (x_arrivee - x_depart) * progression
            y = y_depart + (y_arrivee - y_depart) * progression
            
            # Afficher la carte √† la position actuelle
            self.ia_carte_jouee.dessiner(self.ecran, (int(x), int(y)))
        
        # Afficher les informations des joueurs
        self._afficher_infos_joueurs()
        
        # Afficher un message si c'est la derni√®re chance
        if hasattr(self, 'derniere_chance') and self.derniere_chance:
            last_chance_text = self.gros_texte.render("DERNI√àRE CHANCE!", True, (255, 0, 0))
            text_rect = last_chance_text.get_rect(center=(SCREEN_WIDTH//2, 50))
            self.ecran.blit(last_chance_text, text_rect)
        
        # Afficher un message de fin de partie si n√©cessaire
        if self.partie_terminee:
            self._afficher_ecran_fin()
    
    def _afficher_infos_joueurs(self):
        """Affiche les informations des joueurs"""
        # Joueur humain
        texte_joueur = f"{self.joueur.nom}: {self.joueur.coeurs} ‚ù§ | Cartes: {len(self.joueur.main)}"
        surf_texte = self.police.render(texte_joueur, True, WHITE)
        self.ecran.blit(surf_texte, (20, SCREEN_HEIGHT - 40))
        
        # IA
        texte_ia = f"{self.ia.nom}: {self.ia.coeurs} ‚ù§ | Cartes: {len(self.ia.main)}"
        surf_texte = self.police.render(texte_ia, True, WHITE)
        self.ecran.blit(surf_texte, (20, 20))
        
        # Tour actuel
        tour_texte = f"Tour: {self.joueur_actif.nom}"
        surf_tour = self.police.render(tour_texte, True, WHITE)
        self.ecran.blit(surf_tour, (SCREEN_WIDTH // 2 - 50, 20))
    
    def _afficher_ecran_fin(self):
        """Affiche l'√©cran de fin de partie"""
        # Cr√©er une surface semi-transparente pour le fond
        overlay = pygame.Surface((SCREEN_WIDTH, SCREEN_HEIGHT), pygame.SRCALPHA)
        overlay.fill((0, 0, 0, 180))  # Noir semi-transparent
        self.ecran.blit(overlay, (0, 0))
        
        # D√©terminer le message de victoire
        if hasattr(self, 'gagnant') and self.gagnant and self.gagnant == self.joueur:
            texte = "F√©licitations, vous avez gagn√©!"
            couleur = GOLD
        else:
            texte = "L'IA a gagn√©..."
            couleur = RED
            
        # Afficher le message principal
        texte_surface = self.gros_texte.render(texte, True, couleur)
        texte_rect = texte_surface.get_rect(center=(SCREEN_WIDTH//2, SCREEN_HEIGHT//2 - 50))
        self.ecran.blit(texte_surface, texte_rect)
        
        # Afficher les instructions pour rejouer
        instructions = self.police.render("Appuyez sur R pour rejouer ou ECHAP pour quitter", True, WHITE)
        instructions_rect = instructions.get_rect(center=(SCREEN_WIDTH//2, SCREEN_HEIGHT//2 + 50))
        self.ecran.blit(instructions, instructions_rect)
    
    def gerer_clic_souris(self, pos_souris, type_evenement):
        """G√®re les √©v√©nements de souris
        
        Args:
            pos_souris: Tuple (x, y) de la position de la souris
            type_evenement: Type d'√©v√©nement ('down', 'up', 'motion')
        """
        # Si le menu de s√©lection de symbole est actif
        if hasattr(self, 'menu_actif') and self.menu_actif and type_evenement == 'down':
            # V√©rifier si un bouton de symbole a √©t√© cliqu√©
            for bouton in self.boutons_symbole:
                if bouton['rect'].collidepoint(pos_souris):
                    print(f"[DEBUG] Symbole s√©lectionn√©: {bouton['symbole']}")
                    self.symbole_choisi = bouton['symbole']
                    self.menu_actif = False  # Fermer le menu
                    
                    # Si c'√©tait un Valet qui attendait la s√©lection d'un symbole
                    if hasattr(self, 'carte_valet_en_attente'):
                        # Rejouer la carte Valet maintenant que le symbole est choisi
                        index = self.carte_valet_en_attente
                        delattr(self, 'carte_valet_en_attente')
                        self.jouer_carte(index)
                    return True  # √âv√©nement trait√©
            return False
            
        # Gestion du glisser-d√©poser des cartes (logique existante)
        if type_evenement == 'down' and not self.partie_terminee and self.joueur_actif == self.joueur:
            # V√©rifier si on a cliqu√© sur une carte du joueur
            for i, carte in enumerate(self.joueur.main):
                if carte.rect.collidepoint(pos_souris):
                    self.carte_selectionnee = i
                    self.drag_en_cours = True
                    return True
                    
        elif type_evenement == 'up' and self.drag_en_cours and self.carte_selectionnee is not None:
            self.drag_en_cours = False
            if self.carte_selectionnee < len(self.joueur.main):
                # V√©rifier si la carte est d√©pos√©e sur la pile de d√©fausse
                derniere_carte = self.paquet.obtenir_derniere_carte_defausse()
                if derniere_carte and self.joueur.main[self.carte_selectionnee].peut_etre_jouee_sur(derniere_carte):
                    self.jouer_carte(self.carte_selectionnee)
                # R√©initialiser la position de la carte
                self.carte_selectionnee = None
            return True
            
        elif type_evenement == 'motion' and self.drag_en_cours and self.carte_selectionnee is not None:
            # Mettre √† jour la position de la carte pendant le glisser
            if self.carte_selectionnee < len(self.joueur.main):
                self.joueur.main[self.carte_selectionnee].rect.x = pos_souris[0] - CARD_WIDTH // 2
                self.joueur.main[self.carte_selectionnee].rect.y = pos_souris[1] - CARD_HEIGHT // 2
            return True
            
        return False
        
    def afficher(self):
        """Affiche l'√©tat actuel du jeu"""
        # Effacer l'√©cran
        self.ecran.fill(DARK_GREEN)
        
        # Afficher le menu de s√©lection de symbole si actif
        if hasattr(self, 'menu_actif') and self.menu_actif:
            # Cr√©er un fond semi-transparent
            s = pygame.Surface((SCREEN_WIDTH, SCREEN_HEIGHT), pygame.SRCALPHA)
            s.fill((0, 0, 0, 180))  # Noir semi-transparent
            self.ecran.blit(s, (0, 0))
            
            # Afficher le titre
            texte_titre = self.police.render("Choisissez un symbole :", True, WHITE)
            self.ecran.blit(texte_titre, (SCREEN_WIDTH // 2 - 100, SCREEN_HEIGHT // 2 - 100))
            
            # Afficher les boutons
            for bouton in self.boutons_symbole:
                # Dessiner le bouton
                pygame.draw.rect(self.ecran, WHITE, bouton['rect'], 2)
                pygame.draw.rect(self.ecran, (50, 50, 50), bouton['rect'].inflate(-4, -4))
                
                # Afficher le texte du bouton
                texte = self.police.render(bouton['texte'], True, WHITE)
                texte_rect = texte.get_rect(center=bouton['rect'].center)
                self.ecran.blit(texte, texte_rect)
            
            # Ne pas afficher le reste du jeu tant que le menu est actif
            return
        
        # Afficher l'animation de pioche si elle est en cours
        if self.animation_pioche:
            self.animation_pioche.dessiner(self.ecran, (self.animation_pioche.rect.x, self.animation_pioche.rect.y))
        
        # Afficher la pioche (dos de carte) √† gauche de la d√©fausse
        if hasattr(self.paquet, 'cartes') and len(self.paquet.cartes) > 0:
            pioche_x = PILE_POS[0] - CARD_WIDTH - 20  # 20 pixels d'espacement
            pioche_y = PILE_POS[1]
            
            # Dessiner plusieurs cartes d√©cal√©es pour l'effet de pile
            nb_cartes_visibles = min(3, len(self.paquet.cartes))
            for i in range(nb_cartes_visibles):
                offset = i * 2  # D√©calage de 2 pixels pour chaque carte de la pile
                # Dessiner le rectangle de la carte avec une bordure
                pygame.draw.rect(self.ecran, (0, 0, 120), 
                              (pioche_x + offset, pioche_y + offset, 
                               CARD_WIDTH, CARD_HEIGHT))
                pygame.draw.rect(self.ecran, (200, 200, 200), 
                              (pioche_x + offset, pioche_y + offset, 
                               CARD_WIDTH, CARD_HEIGHT), 2)
            
            # Dessiner le dos de la carte principale par-dessus
            pygame.draw.rect(self.ecran, (0, 0, 150), 
                          (pioche_x, pioche_y, CARD_WIDTH, CARD_HEIGHT))
            pygame.draw.rect(self.ecran, (255, 255, 255), 
                          (pioche_x, pioche_y, CARD_WIDTH, CARD_HEIGHT), 2)
            
            # Ajouter un motif de carte retourn√©e
            pygame.draw.rect(self.ecran, (30, 30, 150), 
                          (pioche_x + 20, pioche_y + 20, 
                           CARD_WIDTH - 40, CARD_HEIGHT - 40))
            pygame.draw.rect(self.ecran, (80, 80, 200), 
                          (pioche_x + 30, pioche_y + 30, 
                           CARD_WIDTH - 60, CARD_HEIGHT - 60))
            
            # Afficher le nombre de cartes restantes dans un badge
            texte = self.police.render(str(len(self.paquet.cartes)), True, (255, 255, 255))
            # Cr√©er un fond arrondi pour le compteur
            counter_bg = pygame.Surface((texte.get_width() + 20, texte.get_height() + 10), pygame.SRCALPHA)
            pygame.draw.rect(counter_bg, (0, 0, 0, 180), 
                          (0, 0, texte.get_width() + 20, texte.get_height() + 10), 
                          border_radius=10)
            self.ecran.blit(counter_bg, (pioche_x + CARD_WIDTH - 30, pioche_y + CARD_HEIGHT - 30))
            # Afficher le texte du compteur
            self.ecran.blit(texte, (pioche_x + CARD_WIDTH - 20, pioche_y + CARD_HEIGHT - 25))
            
        # Afficher la pile de d√©fausse (zone de d√©p√¥t des cartes)
        if hasattr(self.paquet, 'defausse') and len(self.paquet.defausse) > 0:
            # Afficher la derni√®re carte de la d√©fausse
            derniere_carte = self.paquet.defausse[-1]
            derniere_carte.dessiner(self.ecran, (PILE_POS[0], PILE_POS[1]))
            
            # Afficher un contour pour indiquer la zone de d√©p√¥t (seulement si c'est le tour du joueur)
            if self.joueur_actif == self.joueur and not hasattr(self, 'menu_actif'):
                # Cr√©er une surface semi-transparente pour le contour
                contour = pygame.Surface((CARD_WIDTH + 10, CARD_HEIGHT + 10), pygame.SRCALPHA)
                pygame.draw.rect(contour, (255, 255, 255, 100), 
                              (0, 0, CARD_WIDTH + 10, CARD_HEIGHT + 10), 2, border_radius=5)
                self.ecran.blit(contour, (PILE_POS[0] - 5, PILE_POS[1] - 5))
        
        # Afficher les cartes de l'IA (face cach√©e)
        for i, _ in enumerate(self.ia.main):
                        # Utiliser la largeur du dos de la carte ou la largeur par dÈfaut
            card_width = Carte._dos_carte.get_width() if hasattr(Carte, '_dos_carte') and Carte._dos_carte else CARD_WIDTH
                            # Utiliser la largeur rÈelle de la carte pour le positionnement
                card_width = Carte._dos_carte.get_width() if hasattr(Carte, '_dos_carte') and Carte._dos_carte else CARD_WIDTH
                x = 50 + i * (card_width // 2)  # Chevauchement partiel des cartes
            card_height = Carte._dos_carte.get_height() if hasattr(Carte, '_dos_carte') and Carte._dos_carte else CARD_HEIGHT
            if i > 0 and i == len(self.ia.main) - 1:
                x -= 20  # Ajustement pour la derni√®re carte
            y = AI_HAND_Y
            
            # Afficher le dos de la carte pour l'IA
            if hasattr(Carte, '_dos_carte') and Carte._dos_carte:
                self.ecran.blit(Carte._dos_carte, (x, y))
            else:
                                pygame.draw.rect(self.ecran, (0, 0, 150), (x, y, card_width, card_height), border_radius=5)
                                pygame.draw.rect(self.ecran, (0, 0, 0), (x, y, card_width, card_height), 2, border_radius=5)
        
        # Afficher les cartes du joueur (sauf celle en cours de d√©placement)
        for i, carte in enumerate(self.joueur.main):
            if i != self.carte_selectionnee:  # Ne pas afficher la carte s√©lectionn√©e ici
                                # Utiliser la largeur rÈelle de la carte pour le positionnement
                card_width = Carte._dos_carte.get_width() if hasattr(Carte, '_dos_carte') and Carte._dos_carte else CARD_WIDTH
                x = 50 + i * (card_width // 2)
                if i > 0 and i == len(self.joueur.main) - 1:
                    x -= 20
                y = PLAYER_HAND_Y
                # Mettre √† jour la position de la carte
                carte.rect.x = x
                carte.rect.y = y
                # Dessiner la carte √† sa position actuelle
                carte.dessiner(self.ecran, (x, y))
        
        # Afficher la carte s√©lectionn√©e par-dessus tout le reste
        if self.carte_selectionnee is not None and self.carte_selectionnee < len(self.joueur.main):
            carte = self.joueur.main[self.carte_selectionnee]
            # La position est d√©j√† mise √† jour par _gerer_deplacement_souris
            carte.dessiner(self.ecran, (carte.rect.x, carte.rect.y))
            
        # Afficher la carte que l'IA est en train de jouer
        if self.ia_carte_jouee is not None and self.ia_en_cours:
            # Calculer la position actuelle de la carte pendant l'animation
            temps_ecoule = pygame.time.get_ticks() - self.ia_temps_animation
            duree_animation = 500  # 0.5 seconde
            progression = min(temps_ecoule / duree_animation, 1.0)
            
            # Position de d√©part (main de l'IA)
            x_depart = 50 + (self.ia.main.index(self.ia_carte_jouee) if self.ia_carte_jouee in self.ia.main else 0) * (CARD_WIDTH // 2)
            y_depart = AI_HAND_Y
            
            # Position d'arriv√©e (pile de d√©fausse)
            x_arrivee = PILE_POS[0]
            y_arrivee = PILE_POS[1]
            
            # Position actuelle (interpolation lin√©aire)
            x = x_depart + (x_arrivee - x_depart) * progression
            y = y_depart + (y_arrivee - y_depart) * progression
            
            # Afficher la carte √† la position actuelle
            self.ia_carte_jouee.dessiner(self.ecran, (int(x), int(y)))
        
        # Afficher les informations des joueurs
        self._afficher_infos_joueurs()
        
        # Afficher un message si c'est la derni√®re chance
        if hasattr(self, 'derniere_chance') and self.derniere_chance:
            last_chance_text = self.gros_texte.render("DERNI√àRE CHANCE!", True, (255, 0, 0))
            text_rect = last_chance_text.get_rect(center=(SCREEN_WIDTH//2, 50))
            self.ecran.blit(last_chance_text, text_rect)
            x = x_depart + (x_arrivee - x_depart) * progression
            y = y_depart + (y_arrivee - y_depart) * progression
            
            # Afficher la carte √† la position actuelle
            self.ia_carte_jouee.dessiner(self.ecran, (int(x), int(y)))
        
        # Afficher les informations des joueurs
        self._afficher_infos_joueurs()
        
        # Afficher un message si c'est la derni√®re chance
        if hasattr(self, 'derniere_chance') and self.derniere_chance:
            last_chance_text = self.gros_texte.render("DERNI√àRE CHANCE!", True, (255, 0, 0))
            text_rect = last_chance_text.get_rect(center=(SCREEN_WIDTH//2, 50))
            self.ecran.blit(last_chance_text, text_rect)


